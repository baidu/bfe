# 分流转发

## 场景说明

* 假设我们有一个http server对外提供服务，并且有2个服务实例，1个负责处理静态文件请求，另外1个负责处理动态请求
  * 域名：example.org
  * 以/static开头的请求都转向静态文件服务实例；地址：1.1.1.1:8001
  * 其他的动态请求都转向动态服务实例；地址：1.1.1.1:8002

我们可以这样配置完成我们的转发需求，完整的配置详见[route](../../../example_conf/route)

* 将example.org域名关联到产品线example_product（[配置文件](../../../example_conf/route/server_data_conf/host_rule.data)）

```
{
    "Version": "init version",
    "DefaultProduct": null,
    "Hosts": {
        "exampleTag":[
            "example.org" // 域名example.org=>域名标签exampleTag
        ]
    },
    "HostTags": {
        "example_product":[
            "exampleTag" // 域名标签exampleTag=>产品线名称example_product
        ]
    }
}
```

* 配置集群cluster_demo_static和cluster_demo_dynamic 超时、重传以及健康检查的参数（[配置文件](../../../example_conf/route/server_data_conf/cluster_conf.data)）

```
{
    "Version": "init version",
    "Config": {
        "cluster_demo_static": {                    // 集群cluster_demo_static的配置
            "BackendConf": {                        // 后端基础配置
                "TimeoutConnSrv": 2000,             // 连接后端的超时时间:2s
                "TimeoutResponseHeader": 50000,     // 从后端读响应头超时时间:50s
                "MaxIdleConnsPerHost": 0,
                "RetryLevel": 0
            },
            "CheckConf": {                          // 健康检查配置
                "Schem": "http",
                "Uri": "/health_check",
                "Host": "example.org",
                "StatusCode": 200,
                "FailNum": 10,
                "CheckInterval": 1000
            },
            "GslbBasic": {                          // GSLB基础配置
                "CrossRetry": 0,
                "RetryMax": 2,
                "HashConf": {
                    "HashStrategy": 0,
                    "HashHeader": "Cookie:USERID",
                    "SessionSticky": false
                }
            },
            "ClusterBasic": {                       // 集群基础配置
                "TimeoutReadClient": 30000,         // 读用户请求body的超时时间:30s
                "TimeoutWriteClient": 60000,        // 写响应的超时时间:60s
                "TimeoutReadClientAgain": 30000,    // 连接闲置超时时间:30s
                "ReqWriteBufferSize": 512,          // 请求的写buffer大小，512B
                "ReqFlushInterval": 0,              // 刷新请求的间隔时间为0，表示不刷新
                "ResFlushInterval": -1,             // 刷新响应的间隔时间为-1，表示不缓存
                "CancelOnClientClose": false
            }
        },
        "cluster_demo_dynamic": {                   // 集群cluster_demo_dynamic的配置
            "BackendConf": {
                "TimeoutConnSrv": 2000,
                "TimeoutResponseHeader": 50000,
                "MaxIdleConnsPerHost": 0,
                "RetryLevel": 0
            },
            "CheckConf": {
                "Schem": "http",
                "Uri": "/health_check",
                "Host": "example.org",
                "StatusCode": 200,
                "FailNum": 10,
                "CheckInterval": 1000
            },
            "GslbBasic": {
                "CrossRetry": 0,
                "RetryMax": 2,
                "HashConf": {
                    "HashStrategy": 0,
                    "HashHeader": "Cookie:USERID",
                    "SessionSticky": false
                }
            },
            "ClusterBasic": {
                "TimeoutReadClient": 30000,
                "TimeoutWriteClient": 60000,
                "TimeoutReadClientAgain": 30000,   
                "ReqWriteBufferSize": 512,
                "ReqFlushInterval": 0,
                "ResFlushInterval": -1,
                "CancelOnClientClose": false
            }
        }
    }
}
```

* 配置集群下挂载的实例信息（[配置文件](../../../example_conf/route/cluster_conf/cluster_table.data)）
  * 在cluster_demo_static和cluster_demo_dynamic集群下面分别创建子集群demo_static.all和demo_dynamic.all
  * 将静态文件服务实例1.1.1.1:8001挂载到demo_static.all子集群，动态服务实例1.1.1.1:8002挂载到demo_dynamic.all子集群

```
{
    "Version": "init version",
    "Config": {
        "cluster_demo_static": {         // 集群 => 子集群 => 实例列表
            "demo_static.all": [{        // 子集群demo_static.all
                "Addr": "1.1.1.1",       // 实例地址:1.1.1.1
                "Name": "static.A",      // 实例名
                "Port": 8001,            // 实例端口:8001
                "Weight": 1              // 实例权重:1
            }]
        },
        "cluster_demo_dynamic": {
            "demo_dynamic.all": [{
                "Addr": "1.1.1.1",
                "Name": "dynamic.A",
                "Port": 8002,
                "Weight": 1
            }]
        }
    }
}
```

* 配置子集群内负载均衡（[配置文件](../../../example_conf/route/cluster_conf/gslb.data)）
  * cluster_demo_static集群的流量全部转发到demo_static.all子集群
  * cluster_demo_dynamic集群的全部流量全部转发到demo_dynamic.all子集群

```
{
    "Hostname": "",
    "Ts": "0",
    "Clusters": {
        "cluster_demo_static": {       // 集群 => 子集群权重
            "GSLB_BLACKHOLE": 0,       // 黑洞的分流权重为0，表示不丢弃流量
            "demo_static.all": 100     // 权重为100，表示全部分流到demo_static.all
        },
        "cluster_demo_dynamic": {
            "GSLB_BLACKHOLE": 0,
            "demo_dynamic.all": 100
        }
    }
}
```

* 配置分流规则（[配置文件](../../../example_conf/route/server_data_conf/route_rule.data)）
  * 将/static开头的流量转发到cluster_demo_static集群
  * 其余流量转发到cluster_demo_dynamic集群

```
{
    "Version": "init version",
    "ProductRule": {
        "example_product": [    // 产品线 => 分流规则
            {
                // 以/static开头的path分流到cluster_demo_static集群
                "Cond": "req_path_prefix_in(\"/static\", false)",  
                "ClusterName": "cluster_demo_static"
            },
            {
                // 其他流量分流到cluster_demo_dynamic集群
                "Cond": "default_t()",
                "ClusterName": "cluster_demo_dynamic"
            }
        ]
    }
}
```

现在，用curl验证下是否可以转发成功

curl -H "host: example.org" "http://127.1:8080/static/test.html"  将请求转发至1.1.1.1:8001

curl -H "host: example.org" "http://1271:8080/api/test" 将请求转发至1.1.1.1:8002